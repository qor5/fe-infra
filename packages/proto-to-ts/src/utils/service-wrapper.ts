/**
 * Service wrapper generation utilities
 */
import fs from "fs";
import path from "path";
import type { ServiceInfo } from "../types";

/**
 * Extract service name from service file (v2 uses *_pb.ts with GenService)
 */
export function extractServiceInfo(
  filePath: string,
  generatedDir: string,
): ServiceInfo | null {
  try {
    const content = fs.readFileSync(filePath, "utf-8");
    // In v2, match: export const ServiceName: GenService<{ ... }> = ...
    const match = content.match(/export const (\w+):\s*GenService</);
    if (match) {
      const serviceName = match[1];
      // Get relative path from generated directory
      const relativePath = path
        .relative(generatedDir, filePath)
        .replace(/\\/g, "/")
        .replace(/\.ts$/, "");

      return { serviceName, importPath: relativePath };
    }
  } catch (error) {
    console.warn(`âš ï¸  Warning: Could not parse ${filePath}`);
  }
  return null;
}

/**
 * Generate service wrapper code
 */
export function generateServiceWrapper(
  name: string,
  serviceName: string,
  importPath: string,
  moduleName?: string,
): string {
  // Determine the relative path to connect-client and generated files
  const connectClientPath = moduleName
    ? "../../connect-client"
    : "../connect-client";
  const generatedPath = moduleName ? "../generated" : "../generated";

  return `// ${name} Service Client - Auto-generated
// DO NOT EDIT: This file is automatically generated

import { createClient, type Client } from '@connectrpc/connect'
import { ${serviceName} } from '${generatedPath}/${importPath}'
import { transport } from '${connectClientPath}'

/**
 * ${name} Service Client
 * Created using Connect-RPC's createClient with configured transport
 * This provides full TypeScript type inference for all service methods
 */
export const ${name.toLowerCase()}Client: Client<typeof ${serviceName}> = createClient(${serviceName}, transport)
`;
}

/**
 * Generate services index file
 */
export function generateServicesIndexFile(
  services: Array<{ name: string }>,
): string {
  return `// Services Index - Auto-generated exports
// DO NOT EDIT: This file is automatically generated

${services
  .map(
    (s) =>
      `export { ${s.name.toLowerCase()}Client } from './${s.name.toLowerCase()}.client'`,
  )
  .join("\n")}
`;
}

/**
 * Generate service wrappers from scanned files
 */
export async function generateServiceWrappers(
  serviceFiles: string[],
  generatedDir: string,
  servicesDir: string,
  moduleName?: string,
): Promise<void> {
  // Ensure services directory exists
  if (!fs.existsSync(servicesDir)) {
    fs.mkdirSync(servicesDir, { recursive: true });
  }

  const generatedServices: Array<{ name: string }> = [];

  // Generate wrapper for each service file
  for (const filePath of serviceFiles) {
    const serviceInfo = extractServiceInfo(filePath, generatedDir);
    if (!serviceInfo) continue;

    // Extract clean name (remove "Service" suffix if present)
    const cleanName = serviceInfo.serviceName.replace(/Service$/, "");

    const code = generateServiceWrapper(
      cleanName,
      serviceInfo.serviceName,
      serviceInfo.importPath,
      moduleName,
    );

    const outputPath = path.join(
      servicesDir,
      `${cleanName.toLowerCase()}.client.ts`,
    );
    fs.writeFileSync(outputPath, code);
    console.log(`   âœ… Generated ${cleanName} client`);

    generatedServices.push({ name: cleanName });
  }

  // Generate services index file
  if (generatedServices.length > 0) {
    const servicesIndexContent = generateServicesIndexFile(generatedServices);
    const servicesIndexPath = path.join(servicesDir, "index.ts");
    fs.writeFileSync(servicesIndexPath, servicesIndexContent);
    console.log(`   âœ… Generated services index`);
  }

  console.log(`   ðŸ“¦ Total services generated: ${generatedServices.length}`);
}
